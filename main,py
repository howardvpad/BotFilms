import json
import random
from telegram import (
    Update,
    ReplyKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardRemove
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes
)

# –ó–∞–≥—Ä—É–∑–∫–∞ –±–∞–∑—ã —Ñ–∏–ª—å–º–æ–≤
with open('movies_db.json', 'r', encoding='utf-8') as f:
    MOVIES_DB = json.load(f)

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
def main_keyboard():
    return ReplyKeyboardMarkup([
        [KeyboardButton("üé≤ –°–ª—É—á–∞–π–Ω—ã–π —Ñ–∏–ª—å–º")],
        [KeyboardButton("üìã –°–ø–∏—Å–æ–∫ —Ñ–∏–ª—å–º–æ–≤")],
        [KeyboardButton("üîç –ü–æ–∏—Å–∫ —Ñ–∏–ª—å–º–∞")]
    ], resize_keyboard=True)

# –ö–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üé¨ –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=main_keyboard()
    )

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫
async def handle_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    
    if text == "üé≤ –°–ª—É—á–∞–π–Ω—ã–π —Ñ–∏–ª—å–º":
        movie = random.choice(MOVIES_DB)
        await update.message.reply_text(
            f"üé¨ <b>{movie['title']}</b> ({movie['year']})\n"
            f"‚≠ê –†–µ–π—Ç–∏–Ω–≥: {movie['rating']}/10\n"
            f"üìñ –û–ø–∏—Å–∞–Ω–∏–µ: {movie['description']}",
            parse_mode='HTML',
            reply_markup=main_keyboard()
        )
    
    elif text == "üìã –°–ø–∏—Å–æ–∫ —Ñ–∏–ª—å–º–æ–≤":
        movies_list = "\n".join([f"‚Ä¢ {m['title']} ({m['year']})" for m in MOVIES_DB])
        await update.message.reply_text(
            f"üìã <b>–í—Å–µ —Ñ–∏–ª—å–º—ã:</b>\n{movies_list}",
            parse_mode='HTML',
            reply_markup=main_keyboard()
        )
    
    elif text == "üîç –ü–æ–∏—Å–∫ —Ñ–∏–ª—å–º–∞":
        await update.message.reply_text(
            "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ñ–∏–ª—å–º–∞:",
            reply_markup=ReplyKeyboardRemove()
        )
        context.user_data['waiting_for_search'] = True

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–∏—Å–∫–∞
async def handle_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'waiting_for_search' in context.user_data:
        query = update.message.text.lower()
        found = [m for m in MOVIES_DB if query in m["title"].lower()]
        
        if not found:
            await update.message.reply_text(
                "‚ùå –§–∏–ª—å–º –Ω–µ –Ω–∞–π–¥–µ–Ω",
                reply_markup=main_keyboard()
            )
        else:
            movie = found[0]
            await update.message.reply_text(
                f"üé¨ <b>{movie['title']}</b> ({movie['year']})\n"
                f"‚≠ê –†–µ–π—Ç–∏–Ω–≥: {movie['rating']}/10\n"
                f"üìñ –û–ø–∏—Å–∞–Ω–∏–µ: {movie['description']}",
                parse_mode='HTML',
                reply_markup=main_keyboard()
            )
        
        del context.user_data['waiting_for_search']

def main():
    application = Application.builder().token("–í–ê–®_–¢–û–ö–ï–ù").build()
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_buttons))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_search))
    
    application.run_polling()

if __name__ == "__main__":
    main()
